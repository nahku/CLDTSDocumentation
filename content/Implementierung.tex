cd ~/%!TEX root = ../dokumentation.tex


\chapter{Implementation}\label{cha:Implementation}

\section{Lexer}\label{sec:ImplementationLexer}

As mentioned in chapter \ref{sec:ConceptLexer} the implementation of the lexer consists of the definition of tokens in form of regular expression. The following paragraph presents defined tokens and their regular expressions.

\subsubsection{Ignored symbols}
It is possible to declare symbols that should be ignored. However, if a symbol is declared as ignored but is specially mentioned in another token, then if the sequence
of characters represent that token, the ignored symbol is not ignored. In this project, tabs and white spaces are ignored as they do not have any special meaning other than providing clarity.
Also, newlines are generally ignored because as can be seen in listing \ref{lst:Lexer_example_multiline} there are rules that cover multiple lines.

\begin{lstlisting}[basicstyle=\scriptsize	,caption= Multi line production rule,label= lst:Lexer_example_multiline]
<annotated_formula>    ::= <thf_annotated> | <tff_annotated> | <tcf_annotated> |
                           <fof_annotated> | <cnf_annotated> | <tpi_annotated>
\end{lstlisting}

Apart from the ignored symbols, there are 13 defined tokens:

\subsubsection{Expressions}

Expressions can either be of the type grammar, token, strict or macro. It is defined as a nonterminal symbol followed by the production symbol itself (::=,:==,:::,...). The nonterminal symbol and the production are merged to a single token and are not identified as two tokens to avoid ambiguity while parsing. If not it would be difficult for the parer to determine whether the nonterminal symbol that describes the rule is the start of a new rule or does still belong to the previous rule because as mentioned rules can cover multiple lines.

\textit{Regular expression of grammar expression:}  $<\backslash w+>[\backslash s]*::=$

$\backslash w+$ matches any alphanumeric and underscore character that can occur more than one time.
$[\backslash s]*$ matches an arbitrary amount of white spaces. $::=$ matches the symbol for grammar expression and can be substituted  by any other symbol for the other expressions.

\subsubsection{Nonterminal symbol}

A nonterminal symbol starts with \dq <\dq\; and ends with \dq >\dq. In between there is any arbitrary sequence of numbers, underscores and small or capital letters which can be represented by $\backslash w+$ in a regular expression.

\textit{Regular expression of nonterminal symbol:}  $<\backslash w+>$

\subsubsection{Terminal symbol}

%\textit{Regular expression of grammar expression:}  $'[$\backslash '\backslash \backslash \backslash .,a-zA-Z\backslash \textunderscore 0-9\backslash 0-9-\backslash -<>&@!:{}~?^+=/"!^^/@/+-/%;][a-zA-Z\_0-9\-/"!?/@/+-/*/%;\->&+=$\'\\\.,]*'$

\subsubsection{Comment}

A comment is identified by the lexer as a start of a new line followed by a percentage sign followed by an arbitrary character and ends with a newline. Because the percentage sign is also part of the terminal symbols, it is necessary to check whether the percentage sign is in a newline because the terminal symbol is not because the percentage symbol when used as terminal symbol is embedded in square brackets.    

\textit{Regular expression of comment:}  $\textasciicircum \%.*\textdollar $
%$'^%.*\textdollar '$

\subsubsection{Meta-Symbols}

Meta-Symbols include open and close parentheses \dq( )\dq, open and close square brackets \dq[ ]\dq, asterisks \dq *\dq and vertical bars \dq |\dq.

They are recognized by the symbol itself and have a greater meaning for the parser as they impact the to be build data structures. 

\subsubsection{Ambiguity}

The following example could either be matched as one comment token or as comment, grammar expression, non terminal symbol, terminal symbol, non terminal symbol.
This ambiguity is solved because by convention the lexer matches the longest possible token, the sequence of characters is matched as one comment.
\begin{lstlisting}[basicstyle=\scriptsize	,caption= Commented out production rule,label= lst:Lexer_example]
%----   <formula_role> ::= <user_role>-<source>
\end{lstlisting}
\section{Parser}\label{sec:ImplementationParser}

The parser is taking the tokens from the lexer and matches them to defined production rules.




comment block reimplement equal operator

\subsection{Data types}\label{sec:ImplementationDataTypes}

Figure \ref{fig:ImplementationUMLExpressions} contains the UML modelling of the data types described in section \ref{sec:ConceptParserDataStructure}.

-todo update figure rule instead of expression
\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{images/uml_data_types_expressions.pdf}
\caption{UML diagram for rules}
\label{fig:ImplementationUMLRule}
\end{figure}


\begin{figure}[H]
\centering
\includegraphics[width=.7\textwidth]{images/Implementation_parser_symbol_uml.pdf}
\caption{Symbols UML diagram}
\label{fig:ImplementationUMLSymbols}
\end{figure}


\subsection{Defined grammar}\label{sec:ImplementationGrammar}

- Input of parser is formal grammar \\

The grammar is formally specified $G = (N,\sum,P,S)$.

$N$ is the set of nonterminal symbols. The set includes grammar list, comment block, grammar expression, token expression, strict expression, macro expression, productions list, production, xor productions list, t symbol production and production element.

$\sum$ is the set of terminal symbols. Terminal symbols of the specified grammar are the tokens generated by the lexer (see \ref{sec:ConceptLexer}).

$P$ is the set of production rules that are presented in the following. 

A grammar list implies a comment block, the four expressions or a grammar list followed by the expressions.

\begin{align*}
	grammar\;list\; \rightarrow\; &comment\;block
	     		\mid grammar\;expression  \\
			   &\mid token\;expression
                \mid strict\;expression\\
               &\mid macro\;expression \\
               &\mid grammar\;list\;\;\;grammar\;expression\\
               &\mid grammar\;list\;\;\;strict\;expression \\
               &\mid grammar\;list\;\;\;macro\;expression \\
               &\mid grammar\;list\;\;\;comment\;block               
\end{align*}

A comment block is either a comment or a comment block with a comment.

\begin{align*}
    comment\;block\; \rightarrow\; &\textbf{comment}
                \mid comment\;block\;\;\textbf{comment}
\end{align*}

The four expressions are the expression token followed by their productions list. Grammar expression has a special case without a productions list because the production rule $ <null> ::= $ has nothing on the right side. 

\begin{align*}
	grammar\;expression\; \rightarrow\; &\textbf{l grammar expression}\;\;productions\;list \\ 
               &\mid \textbf{l grammar expression} 
\end{align*}
\begin{align*}        
	token\;expression\; \rightarrow\; &\textbf{l token expression} \;\;productions\;list \\ \\
	strict\;expression\; \rightarrow\; &\textbf{l strict expression} \;\;productions\;list \\ \\
	macro\;expression\; \rightarrow\; &\textbf{l macro expression} \;\;productions\;list 
\end{align*}

Productions list and xor productions list imply either a production or a productions list alternative symbol production.
\begin{align*}
        productions\;list\; \rightarrow\; &production \\
               &\mid productions\;list\;\;\textbf{alternative symbol} \;production \\ \\                  
        xor\;productions\;list\; \rightarrow\; &production \\
               &\mid xor\;productions\;list\;\;\textbf{alternative symbol}\;production
\end{align*}
T symbol production is either a t symbol or a t symbol/repetition symbol/ alternative symbol embedded in square brackets.

\begin{align*}
	t\;symbol\;production\; \rightarrow\; & \textbf{open square bracket \; t symbol} \\ &\textbf{close square bracket}\\
               &\mid \textbf{open square bracket \; repetition symbol} \\ &\textbf{close square bracket}\\
               &\mid \textbf{open square bracket \; alternative symbol } \\ &\textbf{close square bracket}\\
               &\mid \textbf{t symbol} 
\end{align*}

Production element can be replaced by a nt symbol or by a nt symbol in square brackets or nt symbol repetition. In the case of repetition or square brackets the production element is categorized as optional when in square brackets or as repetition when followed by the repetition symbol. The same applies to t symbol production. A production element can also only be square brackets only.

 

\begin{align*}
	production\;element\; \rightarrow\; & \textbf{open square bracket \; nt symbol} \\ 
			   &\textbf{close square bracket}\\
               &\mid \textbf{nt symbol \; repetition symbol} \\
               &\mid t\;symbol\;production\;\; \textbf{repetition symbol} \\
               &\mid \textbf{open square bracket \; close square bracket} \\
               &\mid \textbf{nt symbol} \\
               &\mid t\; symbol\; production 
\end{align*}




\begin{align*}
	production\; \rightarrow\; &production\; element
                \mid production\;\; production\; element \\
               &\mid \textbf{open parenthesis}\;\; xor\; \;productions\; list\;\; \\
               &\textbf{close parenthesis} \\
               &\mid \textbf{open parenthesis}\;\; production\;\; \textbf{close parenthesis} \\
               &\mid production \;\;\textbf{open parenthesis}\;\; production \\
               &\textbf{close parenthesis} \\
               &\mid production\;\; \textbf{open parenthesis} \;\;xor \;productions\; list\\
               &\textbf{close parenthesis} \\
               &\mid \textbf{open parenthesis} \;\;production \;\;\textbf{close parenthesis} \\
               &production \\
               &\mid \textbf{open parenthesis}\;\; xor\; productions\; list\\ 
               &\textbf{close parenthesis}\;\; production \\
               &\mid \textbf{open parenthesis}\;\; production\;\; \textbf{close parenthesis} \\
               &\textbf{repetition symbol}\\
               &\mid production\;\; \textbf{open parenthesis} \;\;production \\
               &\textbf{close parenthesis \; repetition symbol}
\end{align*}


- $S$: grammar list, start symbol is not mentioned, per convention by \ac{PLY} first rule found (top level rule)

Listing \ref{lst:Parser_example_productionelement} shows the production rule of the nonterminal $<tfx tuple>$ as well as the tokens that have been generated by the lexer.

\begin{lstlisting}[basicstyle=\scriptsize	,caption= Production element,label= lst:Parser_example_productionelement]
<tfx_tuple>            ::= [] | [<tff_arguments>]
is made of tokens:
l grammar expression open square bracket close square bracket alternative symbol open square bracket nt symbol close square bracket
\end{lstlisting}

The resulting parse tree can be seen in figure \ref{fig:ImplementationParsing}. 

\begin{figure}[H]
\begin{tikzpicture}[
  ->,>=stealth',
  level/.style={level distance=1.5cm,sibling distance=4cm},
  level 2/.style={sibling distance=6cm},
  level 3/.style={sibling distance=5cm},
  level 5/.style={level distance=2cm, sibling distance=4cm},
  level 6/.style={level distance=2cm, sibling distance=4cm}
]
\node {grammar list}
    child{ node  {grammar expression} 
    		child{ node {\textbf{l grammar expression}}}
            child{ node {productions list} 
                child{ node  {productions list}
                	child {node {production}
                		child {node {productions element}
                			child{node {\textbf{\shortstack{open square bracket \\ close square bracket}}}}}}} 
                child{ node  {\textbf{alternative symbol}}}
                child{ node  {production}
                	child {node {productions element}
                		child{node {\textbf{\shortstack{open square bracket \\ nt symbol \\ close square bracket }}}}}}
                				}}
   
; 
\end{tikzpicture}
\caption{Parsing example}
\label{fig:ImplementationParsing}
\end{figure}
                
\subsection{Disambiguation}\label{sec:ImplementationParserDisambiguation}
                
\section{Graph generation}\label{sec:ImplementationGraphGeneration}
todo TPTPGraphBuilder class diagram



- before generating graph node dictionary consisting of nodes is built \\
- Figure \ref{fig:ImplementationNTNodeUML} shows the class NTNode that has already been introduced in chapter \ref{sec:ConceptGraphGeneration}. \\
- Rule Type is Enumeration and can either have the value grammar, token, strict or macro.

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{images/uml_data_types_NTNode.pdf}
\caption{NTNode UML diagram}
\label{fig:ImplementationNTNodeUML}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=.7\textwidth]{images/uml_data_types_rule_type.pdf}
\caption{RuleType UML diagram}
\label{fig:ImplementationRuleTypeUML}
\end{figure}

Algorithm \ref{alg:buildNodesDictionary} shows how the nodes dictionary is build. Iterating the rules list that the parser outputs if the rule is not a comment block a new dictionary item is created that consists of the node key rule name and rule type and the NTNode as value. After iterating, comments are assigned (see chapter REF ).

\begin{algorithm}[H]
\caption{Graph Generation Algorithm: buildNodesDictionary}\label{alg:buildNodesDictionary}
\begin{algorithmic}[1] 
\Require rules\textunderscore list
\ForAll {rules in rules\textunderscore list} 
	\If {rules is not a comment block}
		\State Find rule type for expression
		\State nodes\textunderscore dictionary.update({Node\textunderscore Key(rule.name, rule\textunderscore type):NTNode(rule.name, rules.productions\textunderscore list, rule\textunderscore type, None, rule.position)})
	\EndIf
\EndFor
\State Assign comments to rules
\end{algorithmic}
\end{algorithm}

To generate the graph of a given grammar three algorithms are needed that will be explained in the following.

The algorithm $buildGraphRek$ calls the function $searchProductionsListForNT$ that appends children of a node to the nodes list of children.
The algorithm is first called with the start symbol.
After the children of a node have been appended to the node, every child calls the algorithm resulting in appending their own children to their children's list.

\begin{algorithm}[H]
\caption{Graph Generation Algorithm: buildGraphRek}
\begin{algorithmic}[1] 
\Require node
%\ENSURE $y = x^n$
\State searchProductionsListForNT(node, node.productionsList)
\If {node has children}
	\ForAll {children}
		\State buildGraphRek(child)
	\EndFor
\EndIf
\end{algorithmic}
\end{algorithm}

The right side of a production rule is stored in a productions list.
For identifying the nonterminal or terminal symbols in the productions lists, a loop iterates through all elements of the productions list.
Each element is a production and calls the function $searchProductionForNT$.
This function identifies the children of the given element who are then appended to the node.

\begin{algorithm}[H]
\caption{Algorithm for extracting productions from productions list: searchProductionsListForNT}
\begin{algorithmic}[1] 
\Require node, productionsList
\ForAll {elements in productionsList}
	\State children = new empty list
	\State searchProductionForNT(node, element in productionsList, children)
	\State append children to node
\EndFor
\end{algorithmic}
\end{algorithm}

The goal is to identify the nonterminal symbols.
Therefore it is checked if the production is a nested production and if so, the same function is called again.
If the production is a XOR production list the function $searchProductionsListForNT$ is called to break down the productions list.
If the production element is a nonterminal symbol the element is searched in the node dictionary to get the node where the element is on the left side.
This element is then appended to a list of children. It is possible that an element appears multiple times on the left side if it is presented by multiple expressions.
In this case each element is appended to the list of children.

\begin{algorithm}[H]
\caption{Algorithm for appending children to node: searchProductionForNT}
\begin{algorithmic}[1] 
\Require node, productionsElement, children
\ForAll {elements in productionsElementList}
	\If {element is  a production}
		\State {searchProductionForNT(node, element, children)}
	\ElsIf {element is a XOR productions list}
		\State {searchProductionsListForNT}
	\ElsIf {element is a nonterminal symbol}
		\State find element(s) in node dictionary
		\State append element(s) to children
	\EndIf
\EndFor
\end{algorithmic}
\end{algorithm}
\section{Maintaining comments}\label{sec:ImplementationMaintainingComments}
This section describes the implementation of associating comments with rules, to maintain comments in a generated sub-syntax.
The implementation follows the concept outlined in section \ref{sec:ConceptMaintainingComments}.
Comments are associated after the grammar graph has been generated.
They are associated to the node, that represents the rule they belong to.
For that, the \textit{NTNode} class has a \textit{COMMENT\textunderscore BLOCK} attribute (see \textit{NTNode} UML diagram in figure \ref{fig:ImplementationNTNodeUML}).\\
Associating comments with nodes has the advantage, that when the grammar graph is reduced, only the comments associated with the rules that are part of the sub-syntax are maintained and can also be printed when outputting the sub-syntax.\\

\subsection{Splitting comment blocks}\label{sec:ImplementationMaintainingCommentsSplitByTOP}

-todo describe split comment block by top of page

\subsection{Associating comments with grammar graph nodes}\label{sec:ImplementationMaintainingCommentsAssociateWithNodes}

Algorithm \ref{alg:assign_comments_to_rule} describes the procedure of matching comments to nodes.
-It is used within the \textit{TPTPGraphBuilder} after generating the grammar graph.

The input is the \textit{grammar\textunderscore list}, that the parser created from parsing the \ac{TPTP} syntax file.
The \textit{grammar\textunderscore list} contains rules and comment blocks in the order they appeared in the original \ac{TPTP} syntax file.
The \textit{grammar\textunderscore list} is iterated (line 1).\\
If the current element of the \textit{rules\textunderscore list} is a \textit{COMMENT\textunderscore BLOCK} it is split by top of page lines (line 3).
The procedure of splitting a comment block by top of page lines is described in todo REF.
It returns a list of \textit{COMMENT\textunderscore BLOCK}s.\\
In the following if-clause it is checked, how many \textit{COMMENT\textunderscore BLOCK} are returned.\\
In the first case of one comment block, this \textit{COMMENT\textunderscore BLOCK} should associated with the rule after by default, if that is not possible, because the \textit{COMMENT\textunderscore BLOCK} is at the end of the syntax file, it should be associated with the rule before.
In line 5 it is checked if the \textit{COMMENT\textunderscore BLOCK} is not at the end of the syntax file. This means it should be associated with the rule after.\\
For that the next rule is obtained, by indexing the next element of the \textit{rules\textunderscore list}.
To associate the \textit{COMMENT\textunderscore BLOCK} with the node representing the rule, the node needs to be obtained.
It is more efficient, to use the, on graph generation, created \textit{nodes\textunderscore dictionary} to access the desired nodes, instead of traversing the grammar graph for each wanted node.\\
In the \textit{nodes\textunderscore dictionary}, the key for each node is the nonterminal symbol name and \textit{RuleType} (todo check see section \ref{sec:ImplementationGraphGeneration}).
The rule type of the rules in the \textit{rules\textunderscore list} are indicated by the type of the rule object (see class diagram in figure \ref{fig:ImplementationUMLRule}).
To index the node in the \textit{nodes\textunderscore dictionary} the \textit{RuleType} corresponding to the type of the rule object is needed.
The \textit{find\textunderscore rule\textunderscore type\textunderscore for\textunderscore rule} method determines and returns the \textit{RuleType} corresponding to the rule object type.\\
Using the determined \textit{RuleType} and the nonterminal name, which is stored in the rule, the key for the \textit{Nodes\textunderscore Dictionary} can be constructed (line 8).
Then, the node, to which the \textit{COMMENT\textunderscore BLOCK} should be added is addressed in the \textit{Nodes\textunderscore Dictionary} and the \textit{extend\textunderscore comment\textunderscore block} method of the node called, with the \textit{COMMENT\textunderscore BLOCK} as argument.
The \textit{extend\textunderscore comment\textunderscore block} method is described in section todo REF.
It appends the \textit{COMMENT\textunderscore BLOCK} to the \textit{COMMENT\textunderscore BLOCK} attribute of the node object.\\
If the \textit{COMMENT\textunderscore BLOCK} is at the end of the syntax file, it has to be associated with the rule before.
This case is handled in the else-branch (line 10).
The procedure of adding the \textit{COMMENT\textunderscore BLOCK} to the desired node is essentially the same as described before. The difference lies in that 

 it is checked, whether 
-explain extend comment block method of NTNode

-assign comments to rule in graph builder
-executed assign comments to rule after building nodes dictionary
-follows procedure described in section \ref{sec:ConceptMaintainingComments}

-rules list never two comment blocks in a row

-in \textit{rules\textunderscore list} rules, and comment blocks are present
when comment block occurs
split comment block by top of page method of graph builder
\begin{algorithm}[H]
\small
\caption{Assign comments to rules}
\begin{algorithmic}[1]
\algrenewcommand\algorithmicindent{0.4em}
\Require grammar\textunderscore list
\ForAll {index, expression in rules\textunderscore list.list}
	\If {expression is COMMENT\textunderscore BLOCK}
		\State {comment\textunderscore block\textunderscore list = this.split\textunderscore comment\textunderscore block\textunderscore by\textunderscore top\textunderscore of\textunderscore page(expression)}
		\If{length(comment\textunderscore block\textunderscore list) == 1}
			\If{index < length(rules\textunderscore list.list) - 1}
				\State {next\textunderscore rule = rules\textunderscore list.list[index + 1]}
				\State rule\textunderscore type = this.find\textunderscore rule\textunderscore type\textunderscore for\textunderscore rule(next\textunderscore rule)
				\State {node\textunderscore key = Node\textunderscore Key(next\textunderscore rule.name, rule\textunderscore type)}
				\State this.nodes\textunderscore dictionary[node\textunderscore key].extend\textunderscore comment\textunderscore block(comment\textunderscore block\textunderscore list[0])
				\Else
					\State previous\textunderscore rule = rules\textunderscore list.list[index - 1]
					\State rule\textunderscore type = this.find\textunderscore rule\textunderscore type\textunderscore for\textunderscore rule(previous\textunderscore rule)
					\State node\textunderscore key = Node\textunderscore Key(previous\textunderscore rule.name, rule\textunderscore type)
				\State this.nodes\textunderscore dictionary[node\textunderscore key].extend\textunderscore comment\textunderscore block(comment\textunderscore block\textunderscore list[0])
			\EndIf
		\ElsIf {length(comment\textunderscore block\textunderscore list) == 2}
			\If{index != 0}
				\State previous\textunderscore rule = rules\textunderscore list.list[index - 1]
				\State rule\textunderscore type = this.find\textunderscore rule\textunderscore type\textunderscore for\textunderscore rule(previous\textunderscore rule)
				\State node\textunderscore key = Node\textunderscore Key(previous\textunderscore rule.name, rule\textunderscore type)
				\State this.nodes\textunderscore dictionary[node\textunderscore key].extend\textunderscore comment\textunderscore block(comment\textunderscore block\textunderscore list[0])
			\Else
				\State {next\textunderscore rule = rules\textunderscore list.list[index + 1]}
				\State rule\textunderscore type = this.find\textunderscore rule\textunderscore type\textunderscore for\textunderscore rule(next\textunderscore rule)
				\State {node\textunderscore key = Node\textunderscore Key(next\textunderscore rule.name, rule\textunderscore type)}
				\State this.nodes\textunderscore dictionary[node\textunderscore key].extend\textunderscore comment\textunderscore block(comment\textunderscore block\textunderscore list[0])
			\EndIf
			\If{index < length(rules\textunderscore list.list) - 1)}
				\State {next\textunderscore rule = rules\textunderscore list.list[index + 1]}
				\State rule\textunderscore type = this.find\textunderscore rule\textunderscore type\textunderscore for\textunderscore rule(next\textunderscore rule)
				\State {node\textunderscore key = Node\textunderscore Key(next\textunderscore rule.name, rule\textunderscore type)}
				\State this.nodes\textunderscore dictionary[node\textunderscore key].extend\textunderscore comment\textunderscore block(comment\textunderscore block\textunderscore list[1])
			\Else
				\State previous\textunderscore rule = rules\textunderscore list.list[index - 1]
				\State rule\textunderscore type = this.find\textunderscore rule\textunderscore type\textunderscore for\textunderscore rule(previous\textunderscore rule)
				\State node\textunderscore key = Node\textunderscore Key(previous\textunderscore rule.name, rule\textunderscore type)
				\State this.nodes\textunderscore dictionary[node\textunderscore key].extend\textunderscore comment\textunderscore block(comment\textunderscore block\textunderscore list[1])
			\EndIf
		\ElsIf{length(comment\textunderscore block\textunderscore list) > 2}
		\State \%excluded
		\EndIf
	\EndIf
\EndFor
\end{algorithmic}
\label{alg:assign_comments_to_rule}
\end{algorithm}

\begin{algorithm}[H]
\small
\caption{Append comments to node}
\begin{algorithmic}[1]
\algrenewcommand\algorithmicindent{0.4em}
\Require rule, comment\textunderscore list
\State rule\textunderscore type = find\textunderscore rule\textunderscore type\textunderscore for\textunderscore rule(rule)
\State node\textunderscore key = Node\textunderscore Key(rule.name,rule\textunderscore type)
\State this.nodes\textunderscore dictionary[node\textunderscore key].extend\textunderscore comment\textunderscore block(comment\textunderscore block)
\end{algorithmic}
\label{alg:append_comment_to_node}
\end{algorithm}

-todo explain extend comment block
-comment block extend appends lines to lines already there
\begin{algorithm}[H]
\small
\caption{Extend comment block}
\begin{algorithmic}[1]
\algrenewcommand\algorithmicindent{0.4em}
\Require comment\textunderscore block
\If this.comment\textunderscore block is None
	\State this.comment\textunderscore block = comment\textunderscore block
\Else
	\State this.comment\textunderscore block.extend(comment\textunderscore block.comment\textunderscore lines)
\EndIf
\end{algorithmic}
\label{alg:extend_comment_block}
\end{algorithm}

\section{Extraction of a sub-syntax}\label{sec:ImplementationExtractReducedGrammar}
The following sections describe the algorithms for the extraction of a sub-syntax based on the concept outlined in section \ref{sec:ConceptExtractReducedGrammar}

\subsection{Removal of blocked productions}
Algorithm \ref{alg:remove_blocked_productions} takes the text of the control file as an input argument (control file format description can be found in section \ref{sec:ConceptControlFile}) and removes the productions, that should be blocked, from the nodes.  
The control file string is split into a list of the lines (line 1).
The first line of the control file string, which describes the start symbol, is deleted from the list (line 2) because this information is not needed at this step.\\
Then the following lines are iterated:\\
For each line the content is split by the comma symbol, which produces a list of strings.
The first element of that list is the nonterminal symbol name of the symbol of which productions should be disabled.
The second element is the corresponding rule type symbol.
The nonterminal symbol name and the rule type, that is determined from the rules symbol (line 7), are stored in separate variables.
Then these elements are removed from the list and the remaining elements are converted to integer.
They are the indexes of the productions that should be removed.
The elements are ordered in a descending order (line 10).
Ordering the indexes in that order has the advantage that, when the list of indexes is iterated to delete productions, the indexes of other productions that should be deleted are not changed by the deletion of productions before. ?todo verst√§ndlich?
To delete the productions from the specified node, the node object has to be obtained.
This is done by addressing the node in the \textit{nodes\textunderscore dictionary} with its key consisting of the nonterminal symbol name and the rule type.
From the node, in a loop, the elements of the \textit{productions\textunderscore list} and the \textit{children} list corresponding to the indexes in the control file are deleted.

\begin{algorithm}[H]
\caption{Removing blocked productions}
\begin{algorithmic}[1] 
\Require control\textunderscore string
\State lines = control\textunderscore string.splitlines()
\State delete lines[0]
\ForAll {line in lines}
	\State data = line.splitBy(",")
	\State nonterminal\textunderscore name = data[0] 
	\State rule\textunderscore symbol = data[1]
	\State rule\textunderscore type = determineRuleType(rule\textunderscore symbol)
	\State delete data[0:2]
	\State data = parseInteger(data)
	\State data.sortReverse()
	\State node = this.nodes\textunderscore dictionary.get(Node\textunderscore Key(nonterminal\textunderscore name, rule\textunderscore type))
	\ForAll {index in data}
		\State delete node.productions\textunderscore list.list[index]
		\State delete node.children[index]
	\EndFor
\EndFor
\end{algorithmic}
\label{alg:remove_blocked_productions}
\end{algorithm}

\subsection{Determination of the remaining terminating symbols}
After the desired productions have been deleted from the grammar graph, the next step is to remove the nonterminating symbols from the grammar graph. Algorithm \ref{alg:remove_non_terminating_symbols} shows the procedure of how to remove nonterminating symbols.
First it has to be determined which symbols are terminating and which are nonterminating.

-one way: starting from terminal symbol, find nonterminal symbol that derives terminal symbol, then find nonterminal symbol that only produces terminating symbols
-graph data structure can only be traversed top down not bottom up.
-therefore start at start node, traverse graph, and find terminating symbols
-initialise visited set
-store known terminating symbols

A set of terminating nodes and a temporary set of terminating nodes are initialized.
In the while loop the recursive algorithm \textit{find\textunderscore non\textunderscore terminating\textunderscore symbols(start\textunderscore node, temp\textunderscore terminating, visited)} finds terminating nodes with the start\textunderscore node, and an initialized set of known terminating symbols and a set of already visited nodes.
This algorithm is called with the ?updated? set of terminating symbols until the set does not differ from the run before.
When that is the case all terminating nodes have been found.\\
After all terminating nodes have been found, the productions that contain nonterminating symbols are deleted from the nodes and after that nodes representing nonterminating symbols are removed.\\

In the following parts of the section, first the \textit{find\textunderscore non\textunderscore terminating\textunderscore symbols} algorithm is described. Then the \textit{delete\textunderscore non\textunderscore terminating\textunderscore productions} algorithm and after that the \textit{delete\textunderscore non\textunderscore terminating\textunderscore nodes} algorithm are outlined.

\begin{algorithm}[H]
\caption{Removing non terminating symbols}
\begin{algorithmic}[1] 
\Require start\textunderscore node
\State terminating = new set()
\State temp\textunderscore terminating = new set()
\While {True}
	\State visited = new set()
	\State this.find\textunderscore non\textunderscore terminating\textunderscore symbols(start\textunderscore node, temp\textunderscore terminating, visited)
	\If {terminating == temp\textunderscore terminating}
		\State break
	\Else
		\State terminating = temp\textunderscore terminating
	\EndIf
\EndWhile
\State visited = new set() 
\State delete\textunderscore non\textunderscore terminating\textunderscore productions(start\textunderscore node, terminating, visited)
\State delete\textunderscore non\textunderscore terminating\textunderscore nodes(terminating)
\end{algorithmic}
\label{alg:remove_non_terminating_symbols}
\end{algorithm}

Algorithm \ref{alg:find_non_terminating_symbols}  recursively determines whether a node can be identified as terminating.
The input are a set of already known terminating nodes and nodes that already have been visited.
If the node has been not been visited before it is added to the visited set.
If it has been visited before, the method ends to prevent infinite recursion.
If it has not been visited, the \textit{children} list of the node is iterated. (todo children list contains list of nonterminal symbols per production)
for each children list in node.children
If a \textit{children\textunderscore list} is empty, this means that in a production there are no nonterminal symbols and the production only consists of terminal symbols. If that is the case the node is certainly terminating.\\
If it is not the case, the node is terminating if all nodes in the \textit{children\textunderscore list} represent a terminating nonterminal symbol.
To check that, the algorithm is called recursively for all nodes in the \textit{children\textunderscore list}.
If a nonterminal symbol has multiple rule types it is represented by multiple nodes. Also if a nonterminal symbol with multiple rule types is in featured in a production, all nodes representing that nonterminal symbol are in the children list corresponding to this production. Only one of the nodes needs to be terminating in order for the nonterminal symbol to be terminating.
This is considered in the procedure of checking if a node represents a terminating symbol (line 11), which is described in figure \ref{fig:ImplementationCheckIfValueInTerminating}.
If every node in the \textit{children\textunderscore list} represents a terminating symbol, the node is added to the known terminating nodes.

\begin{algorithm}[H]
\caption{Find non terminating symbols}
\begin{algorithmic}[1] 
\Require node, terminating\textunderscore set, visited\textunderscore set
\State node\textunderscore key = Node\textunderscore Key(node.value, node.rule\textunderscore type)
\If {node\textunderscore key not in visited\textunderscore set}
	\State visited\textunderscore set.add(node\textunderscore key)
	\ForAll {children\textunderscore list in node.children}
		\If{len(children\textunderscore list) == 0}
			\State terminating\textunderscore set.add(node\textunderscore key)
		\Else
			\State terminating\textunderscore flag = True
			\ForAll {child in children\textunderscore list}
				\State find\textunderscore non\textunderscore terminating\textunderscore symbols(child, terminating\textunderscore set, visited\textunderscore set)		
				\If {not value\textunderscore in\textunderscore terminating(child.value, terminating\textunderscore set)}
					\State terminating\textunderscore set = False
				\EndIf
			\EndFor
			\If {terminating\textunderscore flag}
				\State terminating\textunderscore set.add(node\textunderscore key)
			\EndIf
		\EndIf
	\EndFor
\EndIf
\end{algorithmic}
\label{alg:find_non_terminating_symbols}
\end{algorithm}

The flow diagram in figure \ref{fig:ImplementationCheckIfValueInTerminating} shows the procedure to check whether a nonterminal symbol, described by its name, is in the set that contains information on which nodes are known to be terminating.
There can be up to four nodes representing a nonterminal symbol, because it can have up to four rule type (and a node represents the combination of nonterminal symbol name and rule type).\\
In the \textit{terminating\textunderscore set} the \textit{NodeKey}s of known terminating nodes are stored.
A nonterminal symbol is known to be terminating when any node representing that nonterminal symbol is known to be terminating.
If a \textit{NodeKey} of any rule type and  with the nonterminal name is in the \textit{terminating\textunderscore set} then the symbol is terminating and True is returned, otherwise False is returned.
\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{images/Implementation_value_in_terminating.pdf}
\caption{Check if node value is in terminating set}
\label{fig:ImplementationCheckIfValueInTerminating}
\end{figure}

After the terminating symbols have been determined, productions that contain a nonterminating symbol have to be removed from the nodes of the grammar graph because some nonterminal symbols might have productions that contain nonterminating symbols, but also other productions that only contain terminating symbols. Only the productions containing nonterminating symbols have to be removed.\\
Algorithm \ref{alg:delete_non_terminating_productions}  describes how productions that include nonterminating symbols are removed from the grammar graph.
The start node of the graph, the set of known terminating nodes and an empty set of already visited nodes are input at the first call of the algorithm.
If the input node has been visited before it is not visited again, and the algorithm ends. If it has not been visited before the corresponding \textit{Node\textunderscore Key} is added to the set of visited nodes.
Then the \textit{children} list of the node is iterated (line 5).
The index created in line 4 corresponds to the current element of the \textit{children} list, that is iterated. It is needed to delete the \textit{children} list and the corresponding \textit{productions\textunderscore list}, if a production contains nonterminating symbols. The \textit{children} list is iterated in reverse, because, if a \textit{children} list and \textit{productions\textunderscore list} is deleted this will not effect the indexing of the next \textit{children} list to analyse.
The \textit{children} list contains lists of nodes for each production (todo reference). Each list, nested in the \textit{children} list, is iterated and for each node the algorithm is called recursively (line 7 and 8).\\
If a node represent a nonterminating symbol the \textit{not\textunderscore terminating} flag is set to true.
If this flag is true after iteration of one element of the \textit{children} list, it means that the production corresponding to the \textit{children} list element contains at least one nonterminating symbol. If that is the case, the corresponding element of the \textit{children} list and of the \textit{productions\textunderscore list} are removed from the node.
This is repeated for all elements of the \textit{children} list.

As a result of this algorithm, all productions that contained nonterminal symbols have been removed from the grammar graph.

\begin{algorithm}[H]
\caption{Delete non terminating productions}
\begin{algorithmic}[1] 
\Require node, terminating\textunderscore set, visited\textunderscore set
\State node\textunderscore key = Node\textunderscore Key(node.value, node.rule\textunderscore type)
\If{node\textunderscore key not in visited\textunderscore set}
	\State visited\textunderscore set.add(node\textunderscore key)
	\State index = len(node.children) - 1
	\ForAll {children\textunderscore list in reversed(node.children)}
		\State not\textunderscore terminating = False
		\ForAll {child in children\textunderscore list}
			\State delete\textunderscore non\textunderscore terminating\textunderscore productions(child, terminating\textunderscore set, visited\textunderscore set)
			\If{not value\textunderscore in\textunderscore terminating(child.value, terminating\textunderscore set)}
				\State not\textunderscore terminating = true
			\EndIf
		\EndFor
		\If{not\textunderscore terminating}
			\State delete node.children[index]
			\State delete node.productions\textunderscore list.list[index]
		\EndIf
		\State index = index - 1
\EndFor
\EndIf
\end{algorithmic}
\label{alg:delete_non_terminating_productions}
\end{algorithm}

After the productions containing nonterminating symbols have been removed from the grammar graph, the nodes that represet nonterminating symbols can also be removed from the \textit{nodes\textunderscore dictionary}.
Algorithm \ref{alg:delete_non_terminating_nodes} is responsible for this. It takes the set of \textit{Node\textunderscore Key}s as input, that specifies all terminating nodes.
To remove the nonterminating nodes, in a for-loop, all terminating nodes that are addressed by the \textit{Node\textunderscore Key}s are stored in a temporary dictionary. This dictionary replaces the original \textit{nodes\textunderscore dictionary} of the \textit{TPTPGraphBuilder}.
\begin{algorithm}[H]
\caption{Delete non terminating nodes}
\begin{algorithmic}[1] 
\Require terminating\textunderscore set
\State temporary\textunderscore dictionary = \{\}
\ForAll{node\textunderscore key in terminating\textunderscore set}
	\State value = this.nodes\textunderscore dictionary.get(node\textunderscore key, None)
	\State temporary\textunderscore dictionary.update({node\textunderscore key: value})
\EndFor
\State this.nodes\textunderscore dictionary = temporary\textunderscore dictionary
\end{algorithmic}
\label{alg:delete_non_terminating_nodes}
\end{algorithm}

\subsection{Determination of the remaining reachable symbols}
Now, that nonterminating symbols have been removed from the grammar graph, the remaining reachable symbols have to be determined.
As described in section \ref{sec:ConceptRemovingBlockedProductions} the determination of the remaining reachable is done by creating a new grammar graph, with the desired start symbol from the control file.
The new grammar graph will only contain the reachable symbols (as described in section \ref{sec:ConceptDerterminingRemainingReachable}). 
\section{Output generation}\label{sec:ImplementationOutputGeneration}

\subsection{Create output from grammar graph}\label{sec:ImplementationOutputGrammarGraph}
-to generate output from node:
traverse graph and create string represenations of nodes
\subsection{Traverse graph to create string representations of objects}\label{sec:ImpolementationOutputGrammarGraphTraverse}

\subsection{Create string representations of objects}\label{sec:ImplementationOutputGrammarGraphStringRepresentations}

- python has string class \url{https://docs.python.org/3/library/stdtypes.html#str}
- returns string version of the passed object
- it returns object.\textunderscore \textunderscore str \textunderscore \textunderscore () when object has the method
- following classes implement str method:

COMMENT\textunderscore  BLOCK
-lines from lines list with newline

PRODUCTION\textunderscore ELEMENT

PRODUCTION
-order

NTNODE

\subsection{Maintain original order}\label{sec:ImplementationOutputGrammarGraphMaintainOrder}
- use tuple of position and node string


\subsection{Automated parser generator compatibility}\label{sec:ImplementationAutomatedParserGenerator}
-append option

\section{Input/Output}\label{sec:ImplementationInOut}

\section{GUI}\label{sec:ImplementationGUI}
The GUI consists of the class View that can be seen in Figure \ref{fig:ImplementationViewClassDiagram}. The class has the attributes $treeView$ which is an instance of the PyQt QTreeWidget, $graphBuilder$ which is an instance of the TPTPGraphBuilder and the boolean value $commentStatus$. The class functions and their implementation are described in the following sections based on the five sub-menus.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/Implementation_view_class_diagramm.pdf}
\caption{View UML class diagram}
\label{fig:ImplementationViewClassDiagram}
\end{figure}

\subsection{Main application window}\label{sec:ImplementationGUIMainAppli}

\subsubsection{Init GUI}\label{sec:ImplementationGUIInit}

The function $init\textunderscore gui$ sets up the menu bar in the main application window. The menu bar consists of the sub-menus "Import syntax", "Save syntax", "Reduce", "Control file" and "View". To each sub-menu menu actions that have been described in chapter \ref{sec:ConceptGUI} are added and implemented using QActions. The following listing \ref{lst:ImplementationInitGUI} shows the Python code for adding a menu bar and menu actions for example for the "Import syntax" menu bar.

\begin{lstlisting}[language=Python, basicstyle=\scriptsize	,caption= Implementation of menu bar,label= lst:ImplementationInitGUI]
import_menu = menubar.addMenu("Import syntax")
import_menu.addAction(import_tptp_file_action)
import_menu.addAction(import_tptp_file_from_web_action)
\end{lstlisting}

Besides a name, a short cut for executing the menu action is defined. Also triggers have been defined that triggers functions once menu button is pressed. Listing \ref{lst:ImplementationInitGUI2} shows how a short cut and a trigger have been defined for the action $Import TPTP syntax file$.

\begin{lstlisting}[language=Python, basicstyle=\scriptsize	,caption= Implementation of menu actions,label= lst:ImplementationInitGUI2]
import_tptp_file_action = QAction('&Import TPTP syntax file', self)
import_tptp_file_action.setShortcut('Ctrl+O')
import_tptp_file_action.triggered.connect(self.load_tptp_syntax_file)
\end{lstlisting}


\subsubsection{Init TreeView}\label{sec:ImplementationGUIInitTreeView}
Init TreeView is used for displaying a grammar in the main application window. The method is called after importing or reducing a grammar. The grammar is stored in a nodes dictionary whose values (the nodes) are then converted to a list. This list is displayed by transforming it into a tree view. A tree view can be used for displaying nested lists and allowing a user to navigate through them. The tree view consists of all nodes whose leaves are the productions in their (nested) productions list. The nodes can be expanded to see their productions which are then displayed indented and underneath the node.

A new tree view is defined using QTreeWidget with the header labels "Nonterminal", "Production Type" and "Production" (line 1 and 2 in listing \ref{lst:ImplementationInitTreeView}).
All nodes of the nodes dictionary of the GraphBuilder instance are extracted and sorted based on their position in the original \ac{TPTP} syntax file (line 3 and 4 in listing \ref{lst:ImplementationInitTreeView}. 
The pseudo code in \ref{alg:initTreeView} shows the code used for filling the created treeView. For every node a new QTreeWidgetItem is generated. The item consists of the nodes (node.value) and its rule type. Also a new checkbox is defined that is displayed next to the item whose initial value is unchecked. The background colour to set to grey.
For every production in the nodes production list, a new QTreeWidgetItem and checkbox are created as well. However, the default value of the checkbox is set to unchecked. The generated item is then added as a child to the node item. A potential comment block is added to the treeView and the item is added to the treeView as well.

\begin{lstlisting}[language=Python, basicstyle=\scriptsize	,caption= Init Tree View,label= lst:ImplementationInitTreeView]
self.treeView = QTreeWidget()
self.treeView.setHeaderLabels(['Non Terminal', 'Production Type', 'Production'])
nodes_list = list(self.graphBuilder.nodes_dictionary.values())
nodes_list.sort(key=lambda x: x.position)
\end{lstlisting}

\begin{algorithm}[H]
\caption{GUI Pseudo Code: init\textunderscore tree\textunderscore view}
\label{alg:initTreeView}
\begin{algorithmic}[1] 
\ForAll {nodes in nodes\textunderscore list}
	\State rule\textunderscore type = node.rule\textunderscore type
	\State item = new QTreeWidgetItem
    \State Uncheck checkbox of item 
    \State Set background to grey
	\ForAll {productions in node.productions\textunderscore list}
		\State child\textunderscore item = new QTreeWidgetItem
		\State Check checkbox of child item
		\State Add child\textunderscore item to item
	\EndFor    
	\If {node.comment\textunderscore block exists}
		\State comment\textunderscore item = new QTreeWidgetItem
		\State Add comment\textunderscore item to treeView
	\EndIf
	\State Add item to treeView
\EndFor
\end{algorithmic}
\end{algorithm}

\subsection{Import menu}\label{sec:ImplementationGUIImportMenu}	
\subsubsection{Import \ac{TPTP} syntax file}\label{sec:ImplementationGUIImportFile}

The \ac{TPTP} syntax file is imported using QFileDialog which is returning the filename. If the filename is not empty, the application opens a dialog window where the user has to specify a desired start symbol. The method $red\textunderscore text\textunderscore from\textunderscore file$ returns the text of the file belonging to the filename. With the textfile and the start symbol, the method $create\textunderscore tptp\textunderscore view$ is called.

\subsubsection{Import \ac{TPTP} syntax from the \ac{TPTP} website}\label{sec:ImplementationGUIImportInternet}

The \ac{TPTP} syntax file is extracted from the \ac{TPTP} website using the Input method $import\textunderscore tptp\textunderscore syntax\textunderscore from\textunderscore web$ (see chapter REF). This method returns a textfile. The application opens a dialog window where the user has to specify a desired start symbol. With the textfile and the start symbol, the method $create\textunderscore tptp\textunderscore view$ is called.

$create\textunderscore tptp\textunderscore view$ \\
The method creates a new instance of the $TPTPGraphBuilder$, calls $graphBuilder.run$, $init\textunderscore tree\textunderscore view$ and $check\textunderscore start\textunderscore symbol$.

\subsubsection{Check start symbol}\label{sec:ImplementationGUIStartsymbol}

This function checks the checkbox of the defined start symbol. The QTreeView method $findItem(string\; itemName)$ is used that returns all items that match the item name. 
The found items are then checked.

\subsection{View menu}\label{sec:ImplementationGUIViewMenu}
\subsubsection{Toggle comments}\label{sec:ImplementationGUIToggleComments}

Algorithm \ref{alg:toggleComments} shows the algorithm used for toggling comments. The algorithm should either show or hide the comments based on the current state. 
The View class attribute $commentStatus$ indicates whether comments are displayed (true) or not (false). For toggling comments, a new status is set that is the opposite of commentStatus. While looping through every item in $treeView$, comment items can be found by checking whether the item is checkable because by default a comment is not checkable by the user. A QTreeWidgetItem has flags including a flag "ItemIsUserCheckable" that is used for determining whether the item is checkable. The QTreeWidgetItem function $setHidden(bool\;hide)$ is applied on every comment with the value of the new status. CommentStatus is set to the new status. 

-flag(), bitweises AND 

\begin{algorithm}[H]
\caption{GUI Algorithm: toggle\textunderscore comments}
\label{alg:toggleComments}
\begin{algorithmic}[1] 
\State newStatus = not commentStatus
\ForAll {items in treeView}
	\If {item is not checkable}
		\State item.setHidden(newStatus)
	\EndIf
\EndFor
\State commentStatus = newStatus
\end{algorithmic}
\end{algorithm}

\subsection{Reduce menu}\label{sec:ImplementationGUIReduceMenu}
\subsubsection{Reduce \ac{TPTP} syntax with selection}\label{sec:ImplementationGUIReduceWithSelection}

The method reduce \ac{TPTP} syntax with selection reduces the syntax and displays the resulting syntax in the GUI. 
For reducing the \ac{TPTP} syntax based on the users selection in the GUI a control file is produced (see Produce Control file). If no grammar has been imported or no start symbol or multiple start symbol have been selected an error raises. The error is displayed using a QMessageBox. With the produced control file, the Graphbuilder disables blocked productions, treeView is initialized  and the start symbol is checked (see listing \ref{lst:ImplementationGUIReduceTPTPSelection}). 

\begin{lstlisting}[language=Python, basicstyle=\scriptsize	,caption= Reduce TPTP syntax with selection,label= lst:ImplementationGUIReduceTPTPSelection]
control_string, start_symbol = self.produce_control_file()
self.graphBuilder.disable_rules(control_string)
self.init_tree_view()
self.check_start_symbol(start_symbol)
\end{lstlisting}
\subsection{Save syntax menu}\label{sec:ImplementationGUISaveSyntaxMenu}
\subsubsection{Create \ac{TPTP} syntax file from selection}\label{sec:ImplementationGUICreateTPTPFromSelection}

Figure \ref{fig:ImplementationGUIReduceandSave} shows a flow diagram of the process of reducing and saving a \ac{TPTP} syntax file from a users selection.
The input of this method is a boolean value $with\textunderscore comments$ that describes if the syntax should be saved with or without comments for the automatic parser generator (see chapter \ref{sec:ValidationAutomatedParserGeneration}). 
First, the filename is import using a $QFileDialog$.
If the import is successful, meaning a filename has been selected, a control file based on users selection is produced. If the import is not successful, the method terminates. \\
In comparison to \textit{Reduce \ac{TPTP} syntax with selection} the reduced syntax is not displayed in the GUI but only saved to local storage and the GUI displays still the full syntax. If the user wishes to display the reduced syntax in the GUI and save it, he can use the button \textit{Reduce \ac{TPTP} syntax with selection} and then use the button \textit{Reduce and save \ac{TPTP} syntax with selection}.
Because the full syntax is still displayed, the graphBuilder object storing the syntax cannot be modified. Therefore, the old graphBuilder is copied to a new graphBuilder object. Because the old object should not change, the new object should have copies of all objects that are part of the graphBuilder rather than references.
To copy the graphBuilder object which is a compound object it is necessary to use $copy.deepcopy$ instead of $copy.copy$. Deepcopy creates a new object and inserts copies of all objects that are part of to be copied object. Copy however, creates a new object and inserts references to the to be copied objects. 
The new graphBuilder is initialised with the start symbol that has been provided by the generated control file and rules that include blocked productions are disabled. During the initialisation the new start symbol $<start\textunderscore symbol>$ has been added (see chapter \ref{sec:ConceptGraphGeneration} for explanation). This start symbol is searched in the reduced syntax. If it can be found, the syntax is saved with or without comments based on the input parameter. However, if the start symbol cannot be found in the syntax no part of the grammar is terminating. In this case the saved file is empty. To save the grammar the method $Output.save\textunderscore ordered\textunderscore rules\textunderscore from\textunderscore graph(\textunderscore with\textunderscore comments)$ is used.

\begin{figure}[H]
%\centering
\includegraphics[width=1.05\textwidth]{images/implementation_reduce_and_save_tptp_syntax.pdf}
\caption{Reduce and save \ac{TPTP} syntax}
\label{fig:ImplementationGUIReduceandSave}
\end{figure}

Each button in the sub-menu has an associated action. This action is triggered once the button is pressed. In the GUI there are two options of reducing and saving the \ac{TPTP} syntax namely \textit{Reduce and save \ac{TPTP} syntax with selection} and \textit{Reduce and save \ac{TPTP} syntax from selection with external comments}. These two options both call the function described above and in figure \ref{fig:ImplementationGUIReduceandSave}. However, one calls it and passes $with\textunderscore comments$ as true and the other as false. Because each button in the GUI needs it own designated function to call, the functions $create\textunderscore tptp\textunderscore syntax file\textunderscore from\textunderscore selection\textunderscore with\textunderscore comments$ and $create\textunderscore tptp\textunderscore syntax file\textunderscore from\textunderscore selection\textunderscore without\textunderscore comments$ are introduced. They simply set the parameter $with\textunderscore comments$ accordingly and call the function \textit{Create \ac{TPTP} syntax file from selection}.

\subsubsection{Create \ac{TPTP} syntax file from control file}\label{sec:ImplementationGUICreateTPTPFromControlfile}

The previous section explained how a \ac{TPTP} syntax is reduced and saved based on a users selection in the GUI. The described function in this section also reduces and saves a \ac{TPTP} syntax but this time based on an imported control file. The function is similar to the previous function \textit{Create \ac{TPTP} syntax file from selection}. Figure \ref{fig:ImplementationGUIReduceandSaveControl} shows the same flow diagram as figure \ref{fig:ImplementationGUIReduceandSave} but highlights applied changes in red. Changes are that besides importing a filename, a name for the control file has to be imported as well. Instead of producing a control file based on the users selection, the specified control  file is read and the grammar graph is initialised with the start symbol that is specified in the first line of the control file.

Also similar to the previous section, the functions \\ $create\textunderscore tptp\textunderscore syntax\textunderscore from\textunderscore control\textunderscore file\textunderscore with\textunderscore comments$ and \\
$create\textunderscore tptp\textunderscore syntax\textunderscore from\textunderscore control\textunderscore file\textunderscore without\textunderscore comments$ are introduced that set the parameter $with\textunderscore comments$ accordingly and call the function \textit{Create \ac{TPTP} syntax file from control file}.

\begin{figure}[H]
%\centering
\includegraphics[width=1.05\textwidth]{images/implementation_reduce_and_save_tptp_syntax_control.pdf}
\caption{Reduce and save \ac{TPTP} syntax from control file}
\label{fig:ImplementationGUIReduceandSaveControl}
\end{figure}

\subsection{Control file menu}\label{sec:ImplementationGUIControlFileMenu}
\subsubsection{Import control file}\label{sec:ImplementationGUIImportControlFile}

If a control file is imported, checkboxes have to be set accordingly. The pseudo code in \ref{alg:importControlfile} shows the process. 
The name of the control file is read in using a QFileDialog. The file itself is imported using the method $Input.read\textunderscore text\textunderscore from\textunderscore file$ (see chapter REF). If the file exists and if a tree view exists thus a grammar has been imported, all nodes are unchecked and all leaves/productions are checked. The items can be distinguished by looking for whether an item has parents and if not if it is checkable. The checkboxes are set this way because the default mode is that all nodes are unchecked and all productions are checked.  
After setting the checkboxes to the default mode, the first line of the control string is read and the start symbol is set accordingly. If there are multiple start symbols, every start symbol is checked.
Iterating every line of the control string, the nt\textunderscore name which is the first element of a line is saved and the rule\textunderscore type which is the second element as well. The item that belongs to nt\textunderscore name is then searched and every production whose index is listed in the control file is unchecked.

\begin{algorithm}[H]
\caption{GUI Pseudo Code: load\textunderscore controlfile}
\label{alg:importControlfile}
\begin{algorithmic}[1] 
\State Import Control File
\If {Control File exists}
\ForAll {items in tree view}
	\If {parent of item is None}
		\If {item is not a comment}
			\State Uncheck item
		\EndIf
	\Else
		\State Check item 
	\EndIf
\EndFor
\State Get first line of control file
\State Search item that represents start symbol 
\State Check item
\ForAll {lines in control file}
	\State Split line by comma
	\State nt\textunderscore name = first element of split
	\State rule\textunderscore type = second element of split
	\State Search nt\textunderscore name node in tree view
	\If{ parent is None and rule\textunderscore type matches rule\textunderscore type}
		\ForAll {indices in line}
			\If {child exists}
				\State Uncheck child
			\EndIf
		\EndFor
	\EndIf 
\EndFor
\EndIf
\end{algorithmic}
\end{algorithm} 

\subsubsection{Produce control file}\label{sec:ImplementationGUIProduceControlFile}

Algorithm \ref{alg:produceControlfile} shows how the control file used for reducing the \ac{TPTP} syntax is produced. The index of productions that have been blocked by the user in the GUI are identified and stored in a dictionary until further processing. The key of the dictionary is a tuple made of a value and a rule type that has to be defined alongside the dictionary. Besides the blocked productions, the start symbol is featured in the control file as well, therefore an empty list for listing possibly multiple start symbols is created. Multiple start symbols can occur when the nonterminal symbol has multiple rule types or if the users makes an invalid input. The dictionary is used for collecting all blocked productions. Looping through every node of the tree view it is checked, if the item has parents and its checkbox is unchecked. If so, the rule type of the parent is identified and a new tuple is defined. The index of the production in the parents productions list is identified as well. If the tuple is not already in the dictionary, a new dictionary entry is created with the tuple as key and the index of the item as value. If the tuple is already in the dictionary, the index of the item is added to the existing indices. \\
However, if the item is checked and has no parents, the name of the item is appended to the list of start symbols. \\
If there are multiple start symbols in the list that have not he same nonterminal value or no start symbol at all, the user made an invalid input and an error is raised. 
The final control string is made up of first entry of the start symbol list. The first entry is sufficient because the control file only specifies the start symbols name and not the rule type. If there multiple start symbols, they have the same nonterminal name. 
Each in a new line, the nonterminal symbol name, rule type and indices of blocked productions are appended to the control string. Within the line, the name, rule type and indices are separated by a comma.
Moreover, an error is risen if there is no imported grammar, for example the user presses the Reduce grammar button in the GUI without importing a grammar.

\begin{algorithm}[H]
\caption{GUI Algorithm: produce\textunderscore controlfile}
\label{alg:produceControlfile}
\begin{algorithmic}[1] 
\State Define new tuple Entry("Entry", ["value", "rule\textunderscore type"])
\State Create empty dictionary
\State Create empty list $start\textunderscore symbol$
\ForAll {items in treeView}
	\State Get parent of item
	\If {item has parent and is unchecked}
		\State Get rule type of parent
		\State Create entry tuple with name of parent and its rule type
		\State Get index of child from parent
		\If{entry tuple is not in dictionary}
			\State Create new dictionary entry with entry tuple as key and list containing the index of the child as value
		\Else
			\State Append index of child to list
		\EndIf
	\ElsIf {item has no parent and is checked}
		\State Append item name to start symbol list
	\EndIf
\EndFor
\State control\textunderscore string = first entry of start symbol list
\State Append all entries of dictionary to control\textunderscore string
\end{algorithmic}
\end{algorithm} 

\subsubsection{Output control file}\label{sec:ImplementationGUIOutput control file}

Output control file saves a control file to local storage. 
First, a control file is produced based using the method \textit{Produce control file}. A filename under which the control file is stored is input using a QFileDialog window. The control file is then stored using $Output.save\textunderscore text\textunderscore to\textunderscore file$.

\subsection{Exception handling}\label{sec:ImplementationGUIExceptionHandling}

Exceptions are used to handle wrong input from the user. There are three exceptions that are raised whenever the user makes a wrong input: 

\begin{itemize}
\item Multiple start symbols
\item No start symbol
\item No imported grammar
\end{itemize}

The exception \textit{multiple start symbols} is raised if the user selects multiple start symbols in the GUI and presses any Reduce button. On the contrary the exception \textit{no start symbol} is raised if the user selects no start symbol in the GUI and presses any Reduce button. The exception \textit{no imported grammar} is raised if the user starts the application and does not import a grammar but presses a button that requires a grammar for example in the Reduce, View or Control File menu.

\section{Command-line interface}\label{sec:ImplementationCommandLineInterface}
With the argparse module a command-line parser object can be created and parameters can be added to that object.
In the first line of listing \ref{lst:ImplementationArgparseParserConfiguration} the command-line parser object is created with a description.
Lines two to four contain the specification of the accepted arguments.
In addition to the name and short form of the name, the type, a help message, and whether the parameter is optional or not can be specified.
Default values for arguments can also be specified.
If no default value is specified and if the argument is not passed it will have the value \textit{None}.
Argparse automatically checks the given conditions, for example if a required argument is not given and displays an error message if that is the case.

todo listing describe last argument
\begin{lstlisting}[language=Python, basicstyle=\scriptsize	,caption= Argparse command-line parser configuration,label= lst:ImplementationArgparseParserConfiguration]
self.argument_parser = argparse.ArgumentParser(description='Extract sub-syntax using TPTP syntax file and a control file')
self.argument_parser.add_argument('-g', '--grammar', metavar='', type=str, required=True, help='path of the TPTP syntax file')
self.argument_parser.add_argument('-c', '--control', metavar='', type=str, required=True, help='path of the control file')
self.argument_parser.add_argument('-o', '--output', metavar='', type=str, required=False, help='optional output file name (default output.txt)', default= "output.txt")
self.argument_parser.add_argument('-ec', action='store_true', help="flag - include external comment syntax")
\end{lstlisting}

Argparse will also automatically create the help output by using the descriptions provided when configuring the argument parser.


-options for path to grammar and control file
-option for output path

-todo describe seperation of gui and why
